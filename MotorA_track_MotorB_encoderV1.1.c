#pragma config(Sensor, S2,     touchA,         sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
* This program will test the ability to track an input value (encoder from MotorB)
* and have MotorA move according to that input using P(ID), rangeLim, and scaling.
*
* Additional features:
* - set the initial MotorA encoder, using a touch sensor as a limit switch.
* - set the min and max MotorA motion limits: 'if (abs(encoderBdeg) <= inputRangeLim)'
*
*
* Revisions:
* 1.0 - initial 'release' version
* 1.1 - fixed scaling issues due to premature rounding in 'scaleInput' function
*
*/


int rangeLim(int val, int lim) //(abs(val+lim)-abs(val-lim))/2 ...returns vals in range of +/- lim
{
	val = (abs(val+lim)-abs(val-lim))/2;
	return val;
}

int scaleInput(float val, float maxIn, float maxOut) // 'integer normalize' and scale input values
{
  val = val/(maxIn/maxOut);
	return val;
}

task main()
{
	// initialize vars and motor encoder values
	int motorApwr=0;
	int encoderAdeg=0;
	int encoderBdeg=0;
	int inputRangeLim=90;
	int outputMax=100;
	int inputMax=255;
	int topSpeedLim=27;
	int pwrScaling=1;      // eg. motorApwr = motorApwr/pwrScaling;

	nMotorEncoder[motorA]=0;
	nMotorEncoder[motorB]=0;

	// initialize MotorA encoder and position using a touch sensor as a limit switch; then
	// center in approx range of motion
	while (!SensorValue[touchA])
	{
		motor[motorA]=5;
	}

	playSound(soundBlip);
	nMotorEncoder[motorA]=0;
	wait1Msec(500);

	nMotorEncoderTarget[motorA] = 103;
	motor[motorA] = -13;

	while(nMotorRunState[motorA] != runStateIdle)  // while Motor A is still running:
	{
		// do nothing
	}
	motor[motorA] = 0;

	nMotorEncoder[motorA]=0;
	nMotorEncoder[motorB]=0;


	// MotorA follows MotorB with scaling, power, and motion limits
	while (true) {
		encoderBdeg=scaleInput(nMotorEncoder[motorB], inputMax, outputMax);
		if (abs(encoderBdeg) <= inputRangeLim)
		{
			motorApwr=encoderBdeg - nMotorEncoder[motorA];
			motorApwr = motorApwr/pwrScaling;
			motor[motorA] = rangeLim(motorApwr, topSpeedLim);
		}
		else
		{
			motorApwr=sgn(encoderBdeg)*inputRangeLim - nMotorEncoder[motorA];
			motorApwr = motorApwr/pwrScaling;
			motor[motorA] = rangeLim(motorApwr, topSpeedLim);
		}

		encoderAdeg = nMotorEncoder[motorA];
		encoderBdeg = nMotorEncoder[motorB];
		if (SensorValue[touchA]) playSound(soundBlip);
		eraseDisplay();
		displayTextLine(1, "encoderAdeg: %d", encoderAdeg);
		displayTextLine(2, "encoderBdeg: %d", encoderBdeg);
		displayTextLine(3, "motorApwr: %d", motorApwr);
		displayTextLine(6, "RunState(hex):%x", nMotorRunState[motorA]);
		wait1Msec(50);

	} // while end

}
