#pragma config(Sensor, S1,     PIXYC,          sensorI2CCustom)
#pragma config(Sensor, S2,     touchA,         sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
* This program will pan the pixycam to track a object tied to signature. The pixycam is mounted
* directly on the spindle of MotorA. MotorA will move according to the pixycam input
* using P(ID), rangeLim, and scaling.
*
* Additional features:
* - set the initial MotorA position and encoder, using a touch sensor as a limit switch.
* - set the min and max MotorA motion limits: 'if (abs(scaled_xPos) <= inputRangeLim)'
*
*
* Revisions:
* 0.x - development versions
* 2.0 - initial 'release'
*
*/

#include "pixyCamV1-lib-RK1b.h"


int rangeLim(int val, int lim) //(abs(val+lim)-abs(val-lim))/2 ...returns vals in range of +/- lim
{
	val = (abs(val+lim)-abs(val-lim))/2;
	return val;
}

int scaleInput(float val, float maxIn, float maxOut) // scale input values based on ratio
{
	val = val/(maxIn/maxOut);
	return val;
}

task main()
{
	// initialize vars and motor encoder values
	ubyte _qryAddress = 0x51;   // The address of the Signature (51-57)
	ubyte _numberOfBlocks=0;
	ubyte _xPos=0;
	int offset_xPos=0;
	int scaled_xPos=0;
	ubyte _yPos=0;
	ubyte _width=0;
	ubyte _height=0;

	int motorApwr=0;
	int encoderAdeg=0;
	int inputRangeLim=90;
	int outputMax=100;
	int inputMax=126;   // val set to 255/2 since we are using centered '0' and '-125' offset
	int topSpeedLim=15;  // set this to a very low value for initial testing
	int pwrScaling=7;   // eg. motorApwr = motorApwr/pwrScaling
	int toggle=1;

	nMotorEncoder[motorA]=0;

	// initialize pixycam
	initializeI2CSensor(PIXYC, false);
	sleep(150);


	// initialize MotorA encoder and position using a touch sensor as a limit switch; then
	// center in approx range of motion
	while (!SensorValue[touchA])
	{
		motor[motorA]=5;
	}

	playSound(soundBlip);
	nMotorEncoder[motorA]=0;
	wait1Msec(500);

	nMotorEncoderTarget[motorA] = 103;
	motor[motorA] = -13;

	while(nMotorRunState[motorA] != runStateIdle)  // while Motor A is still running:
	{
		// do nothing
	}
	motor[motorA] = 0;

	nMotorEncoder[motorA]=0;


	// MotorA follows _xPos from pixycam (with scaling, power, and motion limits)
	while (true) {
		while (!PIXYCreadSignatureQry(PIXYC, _qryAddress, _numberOfBlocks, _xPos, _yPos, _width, _height))
		{
			//wait for read to return bool 'true'
			sleep(50);
		}

		// if no objects are found, wait 3 seconds, then start scanning, side-to-side
		if (_numberOfBlocks == 0)
		{
			if (time1[T1] > 3000)
			{
				if (offset_xPos >  90) toggle = -1;
				if (offset_xPos < -90) toggle =  1;
				offset_xPos = offset_xPos + toggle;
			}
		}

		// if an object is found, track it in roughly the center of the frame
		else
		{
			clearTimer(T1); // clear (reset) timer 1, which is used to detect how long since last object detected
			offset_xPos= -1 * _xPos + 125;   // invert the sign of _xPos for propper movement correlation
		}

		scaled_xPos=scaleInput(offset_xPos, inputMax, outputMax);

		if (abs(scaled_xPos) <= inputRangeLim)
		{
			motorApwr=scaled_xPos - nMotorEncoder[motorA];
			motorApwr = motorApwr/pwrScaling;
			motor[motorA] = rangeLim(motorApwr, topSpeedLim);
		}
		else
		{
			motorApwr=sgn(scaled_xPos)*inputRangeLim - nMotorEncoder[motorA];
			motorApwr = motorApwr/pwrScaling;
			motor[motorA] = rangeLim(motorApwr, topSpeedLim);
		}

		encoderAdeg = nMotorEncoder[motorA];
		if (SensorValue[touchA]) playSound(soundBlip);
		eraseDisplay();
		displayTextLine(1, "numberOfBlocks: %d", _numberOfBlocks);
		displayTextLine(2, "raw_xPos: %d", _xPos);
		displayTextLine(3, "offset_xPos: %d", offset_xPos);
		displayTextLine(4, "scaled_xPos: %d", scaled_xPos);
		displayTextLine(5, "encoderAdeg: %d", encoderAdeg);
		displayTextLine(6, "motorApwr: %d", motorApwr);
		displayTextLine(7, "RunState(hex):%x", nMotorRunState[motorA]);
		wait1Msec(50);


	} // while end

}
