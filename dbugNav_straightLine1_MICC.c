#pragma config(Sensor, S1,     MICC,           sensorI2CCustom)
#pragma config(Sensor, S2,     HTcompass,      sensorI2CHiTechnicCompass)
#pragma config(Sensor, S3,     HTgyro,         sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorB,          LeftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          RightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
* microinfinity-cruizcore.h provides an API for the MicroInfinity CruizCore XG1300L sensor.
*/

#include "microinfinity-cruizcore.h"

task main ()
{
	short angleI = 0;
	float angleF = 0.0;
	float minF = 0.0;
	float maxF = 0.0;
	//int syncErr=0;

	displayCenteredTextLine(0, "MicroInfinity");
	displayTextLine(1, "CruizCore XG1300L");
	sleep(2000);
	eraseDisplay();

	// There are 3 ranges the Cruizcore XG1300L can measure in
	// up to 2G
	// up to 4G
	// up to 8G
	MICCsetRange8G(MICC);

	// Make sure you always reset the sensor at the beginning of your program
	// The robot needs to be completely stationary or your heading and gyro
	// data won't be accurate.
	MICCreset(MICC);
	wait1Msec(3000);

	displayTextLine(0, "CruizCore XG1300L");
	nMotorEncoder[LeftMotor]=0;
	nMotorEncoder[RightMotor]=0;
	wait1Msec(1);
	nSyncedMotors = synchBC; //motor B is the master, motor C is the slave
	wait1Msec(1);
	nSyncedTurnRatio = 100;
	motor[motorB] = 30; //turn motor B on, which controls motor C at 30% power
	wait1Msec(200);

	while (nMotorEncoder[motorB]<360*8)
	{
		writeDebugStreamLine("First While (nPgmTime,nSyncedTurnRatio,angleF,minF,maxF), %d, %d, %4.2f, %4.2f, %4.2f", nPgmTime,nSyncedTurnRatio,angleF,minF,maxF);
    eraseDisplay();

		// Read the relative heading from the sensor.
		angleI = MICCreadRelativeHeading(MICC);
		angleF = angleI / 100.0;
		if (angleF<minF) minF=angleF;
		if (angleF>maxF) maxF=angleF;

		displayCenteredTextLine(1, "LeftMotor %d",nMotorEncoder[LeftMotor]);
		displayCenteredTextLine(2, "RightMotor %d",nMotorEncoder[RightMotor]);

		/*if (abs(nMotorEncoder[LeftMotor]-nMotorEncoder[RightMotor])>50)
		{
		syncErr++;
		displayCenteredTextLine(3, "syncErr");
		displayCenteredTextLine(4, "%d",syncErr);
		wait1Msec(2);
		}*/

		displayCenteredTextLine(5, "%4.2f, %4.2f", minF, maxF);
		displayCenteredTextLine(6, "TrnRatio  %d", nSyncedTurnRatio);
		displayCenteredTextLine(7, "Heading: %4.2f", angleF);



		if(angleF<0)
		{
			writeDebugStreamLine("if angleF<0 (nPgmTime,nSyncedTurnRatio,angleF,minF,maxF), %d, %d, %4.2f, %4.2f, %4.2f", nPgmTime,nSyncedTurnRatio,angleF,minF,maxF);
			nSyncedMotors = synchBC; //motor B is the master, motor C is the slave
			nSyncedTurnRatio = 100+angleF*1;
			wait1Msec(1);
			motor[motorB] = 30; //turn motor B on, which controls motor C at 30% power
			wait1Msec(1);
		}
		if(angleF>1)
		{
			writeDebugStreamLine("if angleF>1 (nPgmTime,nSyncedTurnRatio,angleF,minF,maxF), %d, %d, %4.2f, %4.2f, %4.2f", nPgmTime,nSyncedTurnRatio,angleF,minF,maxF);
			nSyncedMotors = synchCB; //motor C is the master, motor B is the slave
			nSyncedTurnRatio = 100-angleF*1;
			wait1Msec(1);
			motor[motorC] = 30; //turn motor C on, which controls motor B at 30% power
			wait1Msec(1);
		}
		wait1Msec(100);
	}
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(90000);
}
