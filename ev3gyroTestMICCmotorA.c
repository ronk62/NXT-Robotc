#pragma config(Sensor, S1,     MICC,           sensorI2CCustom)
#pragma config(Motor,  motorA,          MotorA,        tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
* microinfinity-cruizcore.h provides an API for the MicroInfinity CruizCore XG1300L sensor.
*/

#include "microinfinity-cruizcore.h"

int rangeLim(int val, int lim) //(abs(val+lim)-abs(val-lim))/2 ...returns vals in range of +/- lim
{
	val = (abs(val+lim)-abs(val-lim))/2;
	return val;
}

task main ()
{
	short angleI = 0;
	float angleF = 0.0;
	float errF = 0.0;
	float errFsum = 0.0;
	//int mPwr = 10;    --- unused
	//int tic = 1    --- unused
	float minF = 0.0;
	float maxF = 0.0;

	displayCenteredTextLine(0, "MicroInfinity");
	displayTextLine(1, "CruizCore XG1300L");
	sleep(2000);
	eraseDisplay();

	// There are 3 ranges the Cruizcore XG1300L can measure in
	// up to 2G
	// up to 4G
	// up to 8G
	MICCsetRange8G(MICC);

	// Make sure you always reset the sensor at the beginning of your program
	// The robot needs to be completely stationary or your heading and gyro
	// data won't be accurate.
	displayCenteredTextLine(0, "Resetting MICC...");
	displayCenteredTextLine(2, "...HOLD STILL");
	MICCreset(MICC);
	wait1Msec(3000);

	nMotorEncoder[motorA]=0;  // initialize motor location '0' (home base)
	eraseDisplay();

	// Read the relative heading from the sensor.
	angleI = MICCreadRelativeHeading(MICC);
	angleF = angleI / 100.0;

	displayCenteredTextLine(1, "MotorA %d",nMotorEncoder[MotorA]);
	displayCenteredTextLine(3, "Heading: %4.2f", angleF);
	wait1Msec(10000);   // wait to allow time to read initial encoder and gyro vals


	for (int i=0; i<100; i++)
	{
		while(nMotorEncoder[motorA] > -45)  // while Motor A is not at target rotation deg
		{
			motor[motorA] = -2; // ramp up MotorA (neg power = cw motion and incr gyro angle)
		  wait1Msec(100);
			eraseDisplay();

			// Read the relative heading from the sensor.
			angleI = MICCreadRelativeHeading(MICC);
			angleF = angleI / 100.0;

			displayCenteredTextLine(1, "MotorA %d",nMotorEncoder[MotorA]);
			displayCenteredTextLine(3, "Heading: %4.2f", angleF);
			displayCenteredTextLine(5, "iteration:  %d",i;

			wait1Msec(300);
			//tic++;   --- unused

		} // while end

		motor[MotorA]=0; // stop MotorA

		eraseDisplay();

		// Read the relative heading from the sensor.
		angleI = MICCreadRelativeHeading(MICC);
		angleF = angleI / 100.0;

		displayCenteredTextLine(1, "MotorA %d",nMotorEncoder[MotorA]);
		displayCenteredTextLine(3, "Heading: %4.2f", angleF);
		displayCenteredTextLine(5, "iteration:  %d",i;

		wait1Msec(10000);   // wait to allow time to read gyro vals

		// Reverse direction
		while(nMotorEncoder[motorA] < 0)  // while Motor A is not at target rotation deg
		{
			motor[motorA] = 2; // ramp up MotorA (pos power = ccw motion and decr gyro angle)
		  wait1Msec(100);
			eraseDisplay();

			// Read the relative heading from the sensor.
			angleI = MICCreadRelativeHeading(MICC);
			angleF = angleI / 100.0;

			displayCenteredTextLine(1, "MotorA %d",nMotorEncoder[MotorA]);
			displayCenteredTextLine(3, "Heading: %4.2f", angleF);
			displayCenteredTextLine(5, "iteration:  %d",i;

			wait1Msec(300);
			//tic++;   --- unused

		} // while end

		motor[MotorA]=0; // stop MotorA

		eraseDisplay();

		// Read the relative heading from the sensor.
		angleI = MICCreadRelativeHeading(MICC);
		angleF = angleI / 100.0;

		displayCenteredTextLine(1, "MotorA %d",nMotorEncoder[MotorA]);
		displayCenteredTextLine(3, "Heading: %4.2f", angleF);
		displayCenteredTextLine(5, "iteration:  %d",i;

		wait1Msec(10000);   // wait to allow time to read gyro vals

	}  // for end

	while(true);
	{
		wait1Msec(35000);   // continuously wait to allow time to read final data vals
	}

}  // main end
