#pragma config(Sensor, S1,     MICC,           sensorI2CCustom)
#pragma config(Sensor, S2,     HTcompass,      sensorI2CHiTechnicCompass)
#pragma config(Sensor, S3,     HTgyro,         sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorB,          LeftMotor,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          RightMotor,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
* microinfinity-cruizcore.h provides an API for the MicroInfinity CruizCore XG1300L sensor.
*/

#include "microinfinity-cruizcore.h"

/**
int rangeLim(int val, int lim) //(abs(val+lim)-abs(val-lim))/2 ...returns vals in range of +/- lim
{
	val = (abs(val+lim)-abs(val-lim))/2;
	return val;
}
*/

int rangeLim(int val, int lim) //((abs(val+lim/2)-abs(val-lim/2))/2)+lim/2 ...returns vals in range of +/- lim
{
	val = ((abs(val+lim/2)-abs(val-lim/2))/2)+lim/2;
	return val;
}

task main ()
{
	short angleI = 0;
	float angleF = 0.0;
	float errF = 0.0;
	float errFsum = 0.0;
	int pwr = 0;
	float minF = 0.0;
	float maxF = 0.0;

	for (int i=0; i<10; i++)
	{
		nMotorEncoder[LeftMotor]=0;
		//nMotorEncoder[RightMotor]=0;
		wait1Msec(1);
		nSyncedMotors = synchBC; //LeftMotor is the master, RightMotor is the slave
		wait1Msec(1);
		nSyncedTurnRatio = 100;
		//pwr=10+rangeLim(i*5,45);
		pwr=45;
		motor[LeftMotor] = pwr; //turn LeftMotor on, which controls RightMotor at the same power
		wait1Msec(200);

		while (nMotorEncoder[LeftMotor]<360*8)
		{
			writeDebugStreamLine("First While (nPgmTime,pwr,angleF,minF,maxF), %d, %d, %4.2f, %4.2f, %4.2f", nPgmTime,pwr,angleF,minF,maxF);
			eraseDisplay();

			// Read the relative heading from the sensor.
			angleI = 0;
			angleF = angleI / 100.0;
			if (angleF<minF) minF=angleF;
			if (angleF>maxF) maxF=angleF;

			displayCenteredTextLine(1, "LeftMotor %d",nMotorEncoder[LeftMotor]);
			displayCenteredTextLine(2, "RightMotor %d",nMotorEncoder[RightMotor]);
			displayCenteredTextLine(5, "%4.2f, %4.2f", minF, maxF);
			//displayCenteredTextLine(6, "TrnRatio  %d", nSyncedTurnRatio);
			displayCenteredTextLine(7, "Heading: %4.2f", angleF);

			if(nMotorEncoder[LeftMotor]>.5*360*8)
			{
				writeDebugStreamLine("if angleF<0 (nPgmTime,pwr,angleF,minF,maxF), %d, %d, %4.2f, %4.2f, %4.2f", nPgmTime,pwr,angleF,minF,maxF);
				nSyncedMotors = synchBC; //LeftMotor is the master, RightMotor is the slave
				nSyncedTurnRatio = 100+angleF*1;
				wait1Msec(1);
				pwr--;
				pwr=rangeLim(pwr,45);
				motor[LeftMotor] = pwr; //turn LeftMotor on, which controls RightMotor at the same power
				wait1Msec(1);
			}
			/**
			if(angleF>1)
			{
				writeDebugStreamLine("if angleF>1 (nPgmTime,pwr,angleF,minF,maxF), %d, %d, %4.2f, %4.2f, %4.2f", nPgmTime,pwr,angleF,minF,maxF);
				nSyncedMotors = synchCB; //RightMotor is the master, LeftMotor is the slave
				nSyncedTurnRatio = 100-angleF*1;
				wait1Msec(1);
				pwr=10+rangeLim(i*5,45);
				motor[RightMotor] = pwr; //turn RightMotor on, which controls LeftMotor at the same power
				wait1Msec(1);
			}
			*/
			wait1Msec(100);
		} //while end

		motor[LeftMotor]=0; //stop motors and wait for robot to settle
		motor[RightMotor]=0;
		writeDebugStreamLine("drive straight complete (nPgmTime,pwr,angleF,i), %d, %d, %4.2f, %d", nPgmTime,pwr,angleF,i);
		wait1Msec(2000);

	}
}
